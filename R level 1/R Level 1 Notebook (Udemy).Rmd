---
title: "R Level 1"
author: "KM"
date: "2018.02.14･"
output:
  html_document: default
  pdf_document: default
  word_document: default
---

# Section 1
## Lecture 3:

R: programming language
RStudio: GUI (Graphical User Interface)
- click interface
- execute basic commands without code
- accelerate general tasks
- open soruce version for the individual user is available

RCmdr (R Commander)
- focues on a few topics like statistics and graphics
- mainly relies on R Base
- less user-friendly

```{r}
myfirstobject=5:10
plot(myfirstobject)
```

## Lecture 4: Structure of R

The key traits of R
- open-source, high level programming languges used for data analytics purpses. 
 - data entry
 - data pre-processing
 - statistical analysis (modeling, machine learning, prediction)
 - data simulations
 - data visualization
 - web scraping 
 - data visualization for website integration (Shiny)
 
Alternative tools
 - Matlab:engineering
 - Minitab:quality control, six sigma
 - SAS: clinical research, drug development
 - SPSS: academia (social science)

How to work with add-on packages

## Section 1 - Lecture 6: Basic Commands 
### Understanding Functions in R
Setting a seed to make a random sample reproducible, choose any number you want set.seed(65)
```{r}
# with argument name, exact argument order 
set.seed(65)
runif(n = 9, min = 3, max = 6)
# without argument name, exact argument order 
runif(9, 3, 6)
set.seed(65)
# with argument name, mixed argument order 
runif(min = 3, max = 6, n = 9)
set.seed(65)
# without argument name, mixed argument order 
runif(3, 6, 9) # this means n=3, max=9
set.seed(65)
# using only the first argument 
runif(3)
set.seed(65)
# using arguments 1 and 3 
runif(3,,4)
```

### First Coding Steps
complicated codes, sntax erros, faulty codes, typos... , but there are three common mistakes.

(1) Download and activate packages
(2) Case sensitivity
(3) Concatenation

### Object
A data object is a collection of data you want to be used as one. 
- whole dataset
- result of a calculation
- a part of a dataset with specific traits

Different object propertieis/classes determine what we can/cannot od with the data

Classic object class: "data.frame"
- columns for variables
- rows for observsation

Simplest object class vector: vector
- a collection of values of the same class
  - vector+date=time series data/"ts"
  - integfer vector: contains only integer

c() is a contatenation which accomodates values withing the brackets belonging together.

```{r}
# R as a calculater
4 + 4 + 5
# Space does not matter
# Operators: + - / * ^
# Using several operators and round brackets (5-3)^3
# Creating objects x <- c(4,5,6)

# arrows work both directions y
y<-c(4,5.2,76)
c(4,5.2,76)->y
x = c(4, 5, 6)
assign("x", c(4.2, 1, 5)) # function assign

# c for concatenate
x = c(4,5,6)
x # display in console

# semicolon indicates a new row of code
x = c(4,5,6); x 

# See which objects are already created ls()
objects()

# Removing an object 
rm("x")

# Working with vectors 
x = c(y, 5, y) 
x
 nnnnnnnnn   # Sum and roots sum(x)
sqrt(x)

# Values at a given position within the vector 
x[1]

newobject <- x < 5; newobject

# Comparison against original values
x 
```

### Types of brackets
- () round brackets as the standard
 - the standard, mainly used form
 - bind values together witihn a function or an object
 - pre-defined functions use this type of brackets
- [] box brackets for index positions
 - used for data filtering
 - indicate the index position within an object
  - in vector: single value
  - in data frame: row or column
- {} curled brackets for functions and loops
  - used within self-designed functions

### Features of R Functions
a: order of arguments matters.
b: Some of arguments are mandatory, while others are optional.

### Functions: seq, paste, rep
#### sequence() function 
```{r}
# starting with the seq function
?seq 

# just using the default settings
seq()

# simple sequence from 3 to 5 seq(3, 5)
seq(from = 3, to = 5)

# using length 
seq(from = 3, length = 3)

# step manipulations 
seq(from = 3, length = 3, by = 0.5)

# changed order
seq(from = 3, by = 0.5, length = 3) 
```

#### Paste() function

```{r}
?paste
paste(1:4)

# checking the class
class(paste(1:4)) 
paste("xyz", 1:10)

# random vector with numbers and characters
paste("xyz", c(2,5,7,"test", 4.5))
# modifying the seperator
paste("xyz", 1:10, sep = "") 
```

```{r}
?rep 
rep(c(3,4,5), 3)
rep(1:10, times = 3)

x = c(1,2,3) # creating x
# using each
rep(x, each = 3) 
# combining arguments
rep(x, each = 3, times = 3) 

## Working with index positions
x = 4:20

# double equal sign, logical operation
which(x == 10) 
x[3]
```

### Exercise
```{r}
# 1 . Create the object "myobject" and assign the values 1:10 # in at least 3 different ways
myobject<-(1:10)
myobject
assign("myobject", 1:10)
myobject

# 2. Get the sum of your object
sum(myobject)

# 3. Create the following vector by using the paste function "R is great 4 and I will love it" "R is great 7 and I will love it" "R is great 45 and I will love it"
paste("R is great", c(4,7,45),"I will love it")

# 4. vector of 1,2,3 : repeat the vector to get 11 x 1, 10 x 2, and 10 x 3
x<-c(1,2,3)
x2<-x*c(11,10,10)
x2
x=rep(1:3,length=31);x

# 5. What is the value of this vector on position 7
x[7]
```

### Working with data.frames
```{r}
?airmiles
head(airmiles) # first 6 rows
tail(airmiles) # last 6 rows

?mtcars
summary(mtcars)

```


# simple xy plot function of R Base
```{r}
plot(mtcars) 
hist(airmiles) # histogram
head(mtcars)
```

We need to set which data.frame to use for sum function.
```{r}
# sum() function application
sum(mtcars$wt)

# attach to R session environment
attach(mtcars) 
# now R knows which data.frame to use since it is attached
sum(wt) 
# remove it from environment
detach(mtcars) 

# error message since mtcars it not attached any more
sum(wt)

# indext position by box bracket
mtcars[2,6]
mtcars[c(2,5,8),6]
```

### Graphs in R Base
There are three gears of plotting in R.
1. R Base - default
- classic R syntax
- quick on standard task (plot, hist, boxplot, barplot)

2. Lattice
- appropriate for scientific publication
- syntax is similar to R base
- plot matrix

3. ggplot by Hadley Wickham
- sub-language with own syntax
- is getting the standard way of data visualization

```{r}

# 3 main data viz systems: 
# ggplot2, lattice and R Base


# simple scatterplot
x=5:7 # 3 data points, integers 
y=8:10

# default plot output here is a scatterplot 
plot(x,y)

# data is a time series, default here is a line plot 
?lynx
plot(lynx)

# title, color, title color, title magnification 
## cex.main: magnification 
plot(lynx, main="Lynx Trappings", col="red",col.main=52, cex.main=1.5)

# label names 
plot(lynx, ylab="Lynx Trappings", xlab="")

# label orientation
plot(lynx, ylab="Lynx Trappings", xlab="", las=2)

# las - 0:3, scale orientation

# changing the session paramter, 2*2 plot matrix 
par(mfrow=c(2,2), col.axis="red")

plot(1:8, las=0, xlab="xlab", ylab="ylab", main="LAS = 0") 
plot(1:8, las=1, xlab="xlab", ylab="ylab", main="LAS = 1") 
plot(1:8, las=2, xlab="xlab", ylab="ylab", main="LAS = 2") 
plot(1:8, las=3, xlab="xlab", ylab="ylab", main="LAS = 3")

# color manipulation
colors()

# point symbol types
?pch

x=2:4
plot(x, pch="c") # using letters as point symbols
plot(x, pch=13) # symbol nr 13

# Line Types

# setting parameters back to default
par(mfrow=c(1,1), col.axis="black") 

# add on package for "ablineclip", install if not yet available
install.packages("plotrix")
library(plotrix) 

# test plot
plot(1:7, ylab="", main="Line Types lty 0:6", xlab="lty 0:6") 

## ?X???? (trend line)?̒ǉ?
ablineclip(v=1, lty=1, col="sienna2", lwd=2) 
ablineclip(v=2, lty=2, col="sienna2", lwd=2) # dashed 
ablineclip(v=3, lty=3, col="sienna2", lwd=2) # dotted 
ablineclip(v=4, lty=4, col="sienna2", lwd=2) # dotdash 
ablineclip(v=5, lty=5, col="sienna2", lwd=2) # longdash 
ablineclip(v=6, lty=6, col="sienna2", lwd=5) # twodash, thicker for comparison 
ablineclip(v=7, lty=0, col="sienna2", lwd=2) # blank

# plot types of R Base plot
? plot

# by using "type" we can specify which kind of plot we want
plot(lynx) # plot for time series data

plot(lynx, type="p", main="Type p") # points (default) 
plot(lynx, type="l", main="Type l") # lines (default for time series) 
plot(lynx, type="b", main="Type b") # points connected by lines 
plot(lynx, type="b", main="Type c") # lines only of b 
plot(lynx, type="o", main="Type o") # points overlaid by lines 
plot(lynx, type="h", main="Type h") # high density 
plot(lynx, type="s", main="Type s") # steps 
plot(lynx, type="n", main="Type n") # no plot
```

### Example: advanced line plot with R Base
```{r}
# change of plot margins
par(mar=c(4,3,3,3), col.axis="darkgreen")

# adding the explanatory text to plot 1
plot(cars$speed, type="s", col="red", bty="n", xlab="Cars ID", ylab="") 
text(8, 14, "Speed in mph", cex=0.85, col="red") 

par(new=T) # allows 2 in 1 plot

plot(cars$dist, type="s", bty="n", ann=F, axes=F, col="darkblue") axis(side=4, col = "darkblue") 
# y axis for plot 2 text(37, 18, "Stopping distance in ft", cex=0.85, col="darkblue") # explanations to plot 2 title(main="Speed and Stopping\n Distances of Cars") # main title

#??? graphical parameters
?par
par()
```

### Graphs Exercise
```{r}
# 1. get familiar with "rivers" - how many observations? 
# 2. plot rivers against its index (hint: number of observation on x) 
# 3. add: header (red), label names 
# 4. change the point symbol and point color
?rivers


## Solution
?rivers # 141 observations
x = 1:141
y = rivers
plot(x,y, col = "green", pch = 20,      main = "Lengths of\nMajor N. American Rivers",      col.main ="red", xlab = "",      ylab = "length in miles")
```

# section 2: Basics
## Lecture 20: Object types
### Vector
A vector has one dimension and one type of data.
```{r}
myvector<-c(1,1:10)
myvector
length(myvector)
mode(myvector)
class(myvector)
typeof(myvector)
```

### Matrix 
A matrix has two dimensions and one type of data.
```{r}
mymatrix<-matrix(1:10,nrow=2)
length(mymatrix)
mode(mymatrix)
class(mymatrix)
typeof(mymatrix)
```

### Array
has two matrix or more dimensions and one type of data
```{r}
myarray<-array(1:3,dim=c(3,3,3))
myarray
length(myarray)
mode(myarray)
class(myarray)
typeof(myarray)
```

### Data.frame
A data frame is a set of data with different data types, and known as a simplest way to explain. 
```{r}
view(iris)
length(iris)
mode(iris)
typeof(iris)
```

### List
IS a collection of different objects, different data types are possible and common.
```{r}
myList<-list(a=mymatrix, b=myvector)
length(myList)
class(myList)
```

## Lecture 22: Data Types 

There are different ways in which to specify the data types in R. The most important data types are mode and typeof. 
- Mode (storage mode)
  - Example: logical, numeric, compex, character, list,function
    - atomic: logical numeric, complex character
    - recursive: list, function
- Typeof
  - logical, integer, double (like numeric), complex, character, list, closure

```{r}
a = (1:5)
b = rep(1.45,3)
c = c("wed", "tue", "sat")
d = c(1+7i,2+4i)
e = c(T,T,F,F)
fun = function(x) {x+3}
a
mode(a)
typeof(a)

b
mode(b)
typeof(b)

c
mode(c)
typeof(c)

d
mode(d)
typeof(d)

e
mode(e)
typeof(e)
fun

e
f = as.character(e)
f
mode(fun)
typeof(fun)
```

### Lecture 24: Random Number Generation

```{r}
# Normal distribution
rnorm(100, mean=3)
y<- rnorm(100,mean=3)
hist(y)

# default is mean=0, sd=1
rnorm(10)

# Poission distribution
rpois(100, lambda=3)

# Uniform distribution
runif(100)

# to give you a little overview of this distributions
hist(rnorm(1000))
hist(runif(1000))
hist(rpois(1000, 3))
# using set.seed to fix the number generator
set.seed(45)
rnorm (10)
# there is a variety of random generators
# rng.kind argument in set.seed to change the generator
```

Extercises
```{r}
# 1 Get 100 random numbers which are uniformly distributed. Thesebnumbers should be between 1 and 100
x<-runif(100,1,100)

# 2get a vector from this random numbers consisting of every tenth value
x[seq(from=10,by=10,length=10)]


# 3 Find out what the argument la bda in rpois by manipulating it
#lambda speficfies the center of distribution
y<-rpois(1000,lambda=3)
hist(y)

rm(x,y)
```

### Lecture 25: How to export/import of excel files

The best way to do this is via csv files
<- comma separeted values
imporant when importing to excel

```{r}
#To import a csv import
a=1:4
b=c("a","b","c","d")
testdf=cbind(a,b)

# create and store a csv file in the wd:
write.csv(testdf,file="testdf.csv")

# Import a csv file
?read.csv
myImport<-read.csv(file.choose(),header=T)

# read table is a more general approach
myImport2<-read.table(file.choose(),header=T)

# You have to specify the separater
myImport3<-read.table(file.choose(),header=T,sep=",")

# Text file - read.delim
rm(a,b,testdf)
```

#Section 3: Creating objects
## Lecture 30: Matrices (Part1)
```{r}
matrix(c(1,2,3,4,5,6))

# let's see the default settings
?matrix
# number of rows
matrix(c(1,2,3,4,5,6),nrow=2)
# number of columns
matrix(c(1,2,3,4,5,6),ncol=2)
# make sure to have an even number of values
matrix(c(1,2,3,4,5),nc=2)
# identify rows and columns
matrix(c(1,2,3,4),nrow=2,ncol=2, dimnames = list(c("R-1","R-2"),c("C-1","C-2")))

# create a diagonal matrix
x=1:3
diag(x)

Y=diag(x)
Y

# transpose matrix
w <- matrix(c(2,4,8,12),nr=2,nc=2)
w
t(w)

rm(x,w)
```

## Lecture31: Matrices(Part2)
```{r}
# Get the inverse of a matrix
solve(w)

# multiply matrices
c<-matrix(c(5,7,8,9),nr=2)

# get the cross-product
crossprod(w)

# multiply a matrix with a vector
x=1:3
Y=x # dimension check

# solving equation systems
solve(y,x)
```

## Lecture 32: Matrices(excercize)
```{r}
# 1. create the matrix
x=matrix(c(rep(7,3),rep(-7,3),rep(7,3)),nr=3,nc=3,byrow=T,dimnames(list(c("r-1","r-2"),c("c-1","c-2","c-3"))))
# 2. name columns and rows

t(x)*x
crossprod(x)/3
```

## Lecture 35: Lists in R
How to create lists in R.
```{r}
mylist<-list(1:10,c("Tom","Mike","Frank"),rnorm(10))
mylist

names(mylist)<-c("myInteger","myChacter","myNumeric")

# Length of a single elements
length(mylist$myInteger)

# directly name the elements 
mylist2<-list(a=3:5,b=c(4,6,4,9))
mylist2

# work with specific ements of the list
mylist$myChacter
mylist$myChacter[2]

# get the model of the elements
mode(mylist$myNumeric)
mode(mylist$myChacter)

# we can even combine our 2 lists 
combinelist<-c(mylist2, mylist)
combinelist
```

### Excercize
```{r}
# 1 create a list of three elements with three different classes

# 2 extract the value on position 2 of your 2 element in the list
a=c("Hungary", "Italy","Netherland")
b=(rnorm(10))
c=30:45

myexlist=list(a=a,b=b,c=c)
myexlist
myexlist$b[2]

```

## Lecture 38-39: Data Frame Part 1/Part2
Two dimensional objects with different data types
Very useful tool in R
- row: observation
- column: variable

```{r}
?mtcars
mtcars
```


```{r}
country=c("Italy","France","India","Canada")
name=c("tom","Sue","Mike","Jane")
bheight=c(1.87,1.67,1.77,1.76)
bmi=c(23,27,29,21)

# Create a data frame out of several vectors 
survey<-data.frame(country,name,bheight,bmi)
survey

# Add a new vector to an existing data frame
newvec=c(F,T,T,F)
newsurvey<-cbind(survey,newvec)
newsurvey

# Extract a vector out of the data frame
mtcars
mtcars$cyl

# or we can use the attach function
cyl
attach(mtcars)
cyl

# extract a single entry
mtcars

mtcars[2,2]
# extract a row
mtcars[2,]
# extract a column
mtcars[,2]

# logically filter parts of the data set
require(magrittr)

attach(mtcars)
cyl<5

# filter for a subset of data which meets the criteria
mtcars[cyl<5,]

# we can even specify the output columns we want
mtcars[cyl<5,c("mpg","cyl","wt")]

```

## Lecture 40: Factors
Factors can help you to store character data by using factors it is easier to perform calculations. Seome commands require factors to be executed. 

```{r}
iris

iris$Species
# the prolem is that is is sometimes inefficient to handle long characters
# solution: create a vector of factors

as.integer(iris$Species)
new

# factors can be stored as integers - quite handy
FactorSP=as.integer(iris$Species)
newiris=cbind(iris,FactorSP)
newiris

```

## Lecture 40: Exercises for data frame
Get familiar with the dataset iris.
For futher convicnence, I recommend to attach this dataset. 
Learn more about the last column species - how many species are there?

```{r}
attach(iris)
head(iris)
summary(iris$Species)
```


Let us assume we are only interested in the species virginica
- create a logical vector (myFilter) with virginica is T, otherwiseF
- add it to the data frame and call it newiris

```{r}
myFilter=as.integer(iris$Species)
myFilter

myFilter=(Species=="virginica")
myFilter

newiris<-cbind(iris,myFilter)
newiris
```


Create the data frame virginica.s which consists of: 
- sepal.Length and sepal.width of the newiris dataset
```{r}
#newirisext<-newiris[,c("Sepal.Length","Sepal.Width")
#newirisext

virginica.s=newiris[myFilter==T, c("Sepal.Length","Sepal.Width")]
virginica.s
```


Check the class of this new data frame.
```{r}
class(newirisext)
```

# Section 4: Functions in R
## Lecture 44: Introduction to Functions in R

Brief description - R functions are objects
they do calculations for your

R function struture: name function (argument)
They arguments specify the components to be used in the function

```{r}
myfirstfn<-function(x){x+x}
myfirstfn(10)
```

### Stepwise working functions
```{r}
mysecondfn<-function(t,z){
  value=z*3
  value=value*t
  print(value)}

t=5
z=9

mysecondfn(t,z)

```

In this case, the object "value" was used as a stepwise within the function.

Triple dots can be used as a place holder, for any argument to be used open ended.
```{r}
testfunction<-function(...){
mydataframe=data.frame(cbind(...))
print(mydataframe)}

# lets create some vectors
a=(4:7)
b=c("a","g","h","w")

testfunction(a,b)
# as you can see it is a data frame, every row is numbered

# and you can use the function in any way you want as long as the vectors 
c=c(4.6,5.5,8.9,11.3)
testfunction(c,b)
```


# Section 4
## Lecture 46: ifelse statement and summary

Ifelses statement is used to incorporate logical conditions in functions.Ifelse is different from the IF statement (loop section), and the syntax is ifelse (logical condition or test, #calculation if yes, calculation if no).

```{r}
x=4
ifelse(x<5,"target",NA)

# Example no, condition is not met
x=10
ifelse(x<5, "target",NA)
```

Ths can even be nested, and we watch the correct number of brackets. 
Let's create our test vector, and the result should be of same length as this vector.
```{r}
x=c(4,5,6)
ifelse(x<5,"smaller than",
       ifelse(x==5,"equal to","greater than"))
```

The ifelse statement can be used in functions
```{r}
ifelsefun<-function(y,z){
  ifelse(y<7,y+z, "above target")}
ifelsefun(4,2)
ifelsefun(40,7)
```

## Lecture 47: Function Exercises 

1. Moving averages 
Create the function movingavg.
This function is supposed to calculate the moving averages from the vector x, take 3 numbers to calculate your moving avg.

e.g., x=(1:20)
(1+2+3)/3,(2+3+4)/3...

2. Matrix Function
Create the function matrixfun. This function returns a matrix which doubles every ODD number within the initial matrix. Test your function with the matrix (1:4).


3. Ifelse
Create the function nestedfun.
It should take into consideration the following conditions
- x<-9:y+9
- x=9:x
- x=12:NA
- else:x-y

```{r}

# 1 Solution

x=1:20

movingavg = function(x){
  I <- length(x)
  (x[1:(l-2)]+x[2:(l-1)]+x[3:l])/3
  }

y<-movingavg(1:20)

# 2 Solution 

matrixfun<-function(mat){
  mat[mat%%2==1]<-2*mat[mat%%2==1]
  # module operator for odd numbers 
  mat}

mat<-matrix(1:4,ncol=2)
matrixfun(mat)


# 3 Solution 
nestedfun=function(x,y){
  ifelse(x<9,y+9,ifelse(x==9,x,ifelse(x==12,NA,x-y)))
}

x=5:15
y=1:11

nestedfun(x,y)
```

## Lecture 50: Introduction to Loop and If statement 
Loops in R allow us to repeate an operation. In R, you may find the following loops: FOR, WHILE and REPEAT. Plese take care about the brackets. The most common mistake when it comes to loops is not having all brackets closed/opened. You need the curly brackets{} to perform the command line in loop.

Loops come very often together with the if statement.

If statement, we can control which commands to execute under the specific conditions. Most of the time it comes with the else alternative. 
- Syntax: if (condition) {commands if T} else {commands if F}
note that the else part is optional

```{r}

x=10

# Either formula works 
if(x<15){y=T}
if(x<15)z=T

# When you have a short line with only one command, curly brackets are not needed, but it is recommended to use brackets to avoid mistakes. 

# introducing the else part 
if(x<9){y=T}else{y=F}

# Ideal structure of if else codes 

if (x<11){
  y=T
}else{
  y=F
}

# By using else if you can nest numerous commands (e.g., three commands)

x=7

(if(x<7){
  y=T
} else if (x==7){
  y="Target"
}else{
  y=F
})
```

## Lecture 51: For loop
For loops allow a cetain operation to be repeated a fix nr of times. This is oppsed to the while loop where the rep nr is not prefixed. This syntax looks like this: for (name in vecot){commands}
2
```{r}
for (i in 1:15){print(i)}
for (z in 1:15){print(z)}
```

Variable names does not matter although you will see i quite often. 

To skip certain elements in the loop:next
```{r}
for (i in 1:12){
  if(i==3)
    next
  print(i)
  }
```

To break/stop the loop:break 
```{r}
for (i in 1:12){
  if(i==3)
    break
  print(i)
}
```

Break and Next are useful arguments which are also working in the other loop type.

Let us create the Fibonacci sequence, in this case the fdirst 20 numbers. This is a famous sequence of numers which is used e.g., in stock market predictions. It starts with 2*1 and continues with the summation of the 2 preceding elements. 

With the first line we create an empty vector
```{r}
Fibonacci=c()
```

We define the first two numbers, and we create the loop to calculate positions3 to 20 
```{r}
(Fibonacci[1]=Fibonacci[2]=1)
for (i in 3:20){Fibonacci[i]=Fibonacci[i-2]+Fibonacci[i-1]}
Fibonacci
```

## Lecture52:  While loop
If we want to repeate statements, but we do not yet know about the pattern of repetition. As long as the condition holds the calculation is performed. 
- Syntax: while (condition){commands}

1. X meets condition (command in curly brackets is performed)
```{r}
x=4
while(x<5){
  x=x+10
  print(x)
}
```

2. Y does not meet condition 
```{r}
y=6
while(y<5){
  y=y+10
  print(y)
}
```

Let us walk through another Fibonacci example. We want to know all Fibonacci numbers below 400, and we do not know many there are so we use the while loop.

- We create the first 2 numbers
```{r}
Fi1=1
Fi2=1
```

- The basic Fibonacci vector,mnote that I put only Fi2 in it to have only 2x1 at the beginning. The loop is going to fill the vector step by step. 
```{r}
Fibonacci=c(Fi2)

# With the while statement, we start the loop and define 400 as our condition
while (Fi2<400) {
  Fibonacci=c(Fibonacci,Fi2)
  oldFi2=Fi2 # to convert Fi2 to the old Fi2 value, which later on gets Fi1
  Fi2=Fi1+Fi2 # to update the latest number
  Fi1=oldFi2 # to update Fi1 to the old Fi2
}
Fibonacci
```

## Lecture 53: Repeate Loop
This loop is used infrequently - however sometimes it can be useful. The idea is to repeate a cetain statement endlessly (difference to FOR). With the break statement, we terminate the loop.
- Syntax: repeat {statement} if (condition) break

```{r}
x=1
repeat{
  x=x+3
  if (x>99)
    break
  print(x)
}
```

Note that the position of the print command determins if x-3 or x is printed. This can be seen in the last number output. 

```{r}
x=1
repeat{
  x=x+3
  print(x)
  if(x>99)
    break
}
```

## Lecture 54: Excercise
1. Create a simple simple loop ranging from 10:40. 
Print all te numbers and insert "My first FOR loop in R" when i is 22.

2. 
a: choose an appropriate loop to print all numbers <1000 in the lynx dataset
b: now print te dataset as follows
- trapping<1000 should be replaced by "Low trapping rate"
- traping >1000 should appear as the actual number
- trapping=1000 should be replaced by "Target rate"
### hint: watch the breaket and use else if

3. While loop: if you look at the example code for the Fibonacci numbers which we calculated in the lecture, can we work out a wat to do the calculation without using oldFib?

```{r}
#1: solution 
for (i in 10:40){
if (i==22)
  print("My first FOR loop in R")
  print(i)
}

#2-a: solution
require(lynx)
lynx
names(lynx)
(state=row.names(lynx))
edit(lynx)

for (i in lynx){
  if(i<1000)
    print(i)
}

data.frame(lynx)
plot(lynx)

#2-b: solution
for (i in lynx){
  if(i<1000){
    print("Low trapping rate")
  } else if (i>1000){
    print(i)
  }else{
    print("Target rate")
  }
}

#3: solution
Fi1=1
Fi2=1
Fibonacci=c(Fi2)

while (Fi2<400) {
  Fibonacci=c(Fibonacci,Fi2)
  oldFi2=Fi2 
  Fi2=Fi1+Fi2 
  Fi1=max(Fibonacci)
}
Fibonacci

```

4. (HARD) Write a function to calculate all prime numbers up to 100, starting from 2. In the solution, we are using the erastosthenes method (the oldest known systematic method)
hint: function "any" may help, modules division %%
```{r}

Primevec=function(n){
  if(n>=2){
    s=seq(2,n)
    p=c()
    for(i in seq(2,n)){
      if (any(s==1)){
        p=c(p,i)
        s=c(s[(s%%i)!=0],i)
      }}
    return(p)}else{
    stop("Input at least 2")
  }}
Primevec(100)



PrimVec = function(n){
 # to start from 2
 if (n>=2) {
 # to further specify the sequence we want to work with
 s = seq(2,n)
 # p will be the container for our primes,
 # numbers will be moved from s to p step by step if they meet the
criteria
 p = c()
 # we start the loop
 for (i in seq(2,n)){
 # we use any to check that i (of this loop round) is still in s, multiples of i will be removed
 if(any(s==i)){
 # we store i if it meets our criteria in p together with the previous p
 p = c(p,i)
 # to search for numbers with a remainder at modulus division
 s = c(s[(s%%i) != 0],i)
 }}
 return(p) }
 # to specify the output if n < 2 (optional)
 else{
 stop("Input at least 2")
 }}
Primvec(100)

```

## Section57:Introduction to apply family
An elegant way to do loops

- Apply (arrays - matrices)
- tapply (vectors can be split in different subsets)
- lapply(the whole subfamily is for vectors or lists)
- sapply(user firendly version of lappy)
- vapply(similar to sapply, modified return value )
- replicate (random nr generation)

- rapply(similar to lapply)
- eapply(environment, generates a list)
- mapply(mutivariate, similar to sapply)
bydata frames, similar to tapply, factors needed, splits the df und does calculus on subset. 

### APPLY
```{r}

# apply 

# apply(X, Margin, Fun,...)
(X = matrix(c(1:9),nr=3,byrow=T))

# Mrgin::1 for row, 2 for col
apply(X,1,mean) # gives the mean of every row
apply(X,2,mean) # gives the mean of every column

apply(X,1,plot) # even graphics functions are permissible
```

### TAPPLY
```{r}
# tapply
?tapply


# We use tapply to work with subsets of vectors 
# tapply factor (given by the INDEX) determins which group 
tapply(1:4,c(3,3,3,3),sum,simplifiy=F)
# To get two groups 
tapply(1:4, c(3,3,3,4),sum,simplify = F)
# Simplify gets just another output
tapply(1:4,c(3,3,3,4),sum,simplify=T)

```

### BY
BY is similar to tapply, but can be used for dataframes. Data can be split into subsets.
```{r}
?by
head(iris)

by(iris[1:4],iris$Species,colMeans)

E we need to specify which column we want to work with []
by(iris[2:4],iris$Species,colMeans)
```

## Lecture 59: Eapply, sapply, lapply
### eapply
```{r}
?eapply

# create an environment
e<-new.env()
e$e1<-(3:8)
e$e2<-(56:61)
e
eapply(e,mean)

```

### lappy (whole subfamily)
```{r}
?lapply

# we use lappy for lists
mylist<-list(a=(1:10),b=(45:77))
mylist

# result has same length at the list (here 2)
resultapply<-lapply(mylist,sum)
resultapply

# or vectors
myvector<-c(1:20)
lapply(myvector,sum)

```

### sapply
```{r}
?sapply
resultssapply <- sapply(mylist,sum) 
resultssapply

# we do get the same results as lapply, however, the ouput is different. In this case, we get a userfriendly vec or matrix. 
```

## Lecture60: Vapply, replicate, mapply
### vapply
```{r}
?vapply

# similar to sapply but the output can be specified
# classic example is fivenum function (five nr summary)
resultsvapply <- vapply(mylist,fivenum,
                        c(Min.=0,"1st Qu."=0,Median=0,
                          "3rd Qu."=0,Max.=0))
resultsvapply

```

Result is a matrix with row names = output functions and col names=list names. 

### replicate
This allows for replication of random number generation (Result is a matrix).
```{r}
resultsreplicate<-replicate(7,runif(10))
resultsreplicate
```

### mapply
Mapply is similar to sapply but multivariate, and functions are applied in different levels.
```{r}
?mapply
mapply(rep,1:4,4:1)

# That means number 4 is rep 4*, number 2 is rep 3*, etc.
# recycling (length must be a multiple)

mapply(rep,1:8, 4:1)
```

nr 1 and nr 5 should be rep 4* in this case. 
This is a good way to work with different elements of a list (list$element.name).

## Lecture 61: rapply and summary
### rapply
This function is similar to lapply.
```{r}
?rapply
list1<-list(a=c(1:5),b=c(6:10))
list1

rapply(list1,sum)
rapply(list1,sum,how="list")

# default to how is "unlist", which in fact is a vector.
# Other options are "list" and "rep"

a=c(TRUE,TRUE,TRUE)
b=c(1:3)

# use the class argument to apply the function only to this class of the mixed list
list2<-list(a=a,b=b)
list2

rapply(list2, median, class="integer")
# the class argument is a good way to handle mixed lists 
```

## Lecture 62: Apply Family Exercises 

1. IF you take a look at the 4 functions: rowSums, rowMeans,colSums, colMeans
Could we use the apply function get the same results?


2. mapply:create 2 lists consisting of 3 elements each. All elements have the same length. Get the sum and mean of all ements of list 1 and element 2 and 3 from list 2. The results should be 2 vectors (sum, mean) of the same length as the elements


3. Generate a vector of 100 random nrs (rnorm)
There are 3 groups: gr1 has numbers 1:40, gr2(41-70) and gr3(71-100). Get the sum and the mean of those groups by using a suitable function of the apply family.

4. Create a matrix of 4 rows and 5 columns with random normal distributed numbers with mean 8. Make the result reproducible. Calcuate the mean for every row. 

5. Create a mixed list (3 components) of 2*3 numeric values and 3 logicals. Tha means a is logical, b and c are numeric. Choose a suitable function and calculate the sum of two numeric components. 

```{r}

# 1. Apply 
(X = matrix(c(1:9),nr=3,byrow=T))

# Mrgin::1 for row, 2 for col
apply(X,1,mean)
apply(X,1,sum)
apply(X,2,mean) 
apply(X,2,sum) 

# 2. Mapply
a <- c(1:5)
b <- c(4:8)
c <- c(8:12)
d <- c(16:20)
f <- c(20:24)

list1 <- list(a=a,b=b,c=C)
list2 <- list(d=d,e=e,f=f)

mapply(sum,list1$a,list1$b,list1$c,list2$e,list2$f)
mapply(mean,list1$a,list1$b,list1$c,list2$e,list2$f)

# 3. Random Number Generation
x <- rnorm(100)
y <- c(rep(1,times=40),rep(2,times=30),rep(3,times=30))

tapply(x,y,sum)
tapply(x,y,mean)

# 4. Matrix for random number
set.seed(34)
g <- replicate(5,rnorm(4,8))
apply(g,1,mean)

# 5. Mxied matrix for logical and random number
a <- c(F,T,F)
b <- c(4.3,6.7,5.9)
c <- c(4.3,6.7,5.9)
(mylist=list(a=a,b=b,c=c))
rapply(mylist,sum,class="numeric")

```

# Section 7: Graphs in R
## Lecture 65: Graphs in R
Recommended package: ggplot2 and lattice 

```{r}
?par
par()

par(bty="u")
plot(lynx)


```

### Boxplots
Boxplots are perfect way to compare distributions of different groups, which allow a good overview: min, max,med. quantiles 1 and 3, outliers. They often come together with ANOVA. standard tool for publications. 

```{r}
?sleep
head(sleep)
sleepboxplot=boxplot(data=sleep,extra~group,
                     min="Change in sleep duration",
                     col.main="red",ylab="change in hrs",xlab="drug")

attach(sleep)
means=by(extra,group,mean)
points(means,col="red")
```

Change the orentation of the boxplot: horizontal=T
```{r}
horizontalboxplot=boxplot(data=sleep,extra~group,ylab="",xlab="",
                         horizontal=T)
```

To intergrate different colours for te boxplots
```{r}
horizontalboxplot <- boxplot(data=sleep,extra~group,
                             ylab="",xlab="",horizontal=T,
                             col=c("gray","light blue"))
```

## Lecture 68: Exporting Graphs
```{r}
par(bty="o")
plot(c(4,6,7),c(8,3,5),las=0,pch=20)
par()
colours()
example(points)
```

## Lecture 69: Boxplot Excersize
1. get familar with dataset: plantGrowth
2. Perform a boxplot stratfied by the three treatment groups
3. remove the box surrounding the plot
4. resemble the heading as below 
5. name the boxes in the x axes
6. insert a blue dot for the mean in each box

```{r}
?PlantGrowth
head(PlantGrowth)
d <- PlantGrowth

require(stats)
par(bty="n")
boxplot(data=PlantGrowth,weight~group)

means <- by(PlantGrowth$weight,PlantGrowth$group,mean)

boxplot(data=PlantGrowth,weight~group,ylab="plant weight",main="Treatment Effect \n on plant growth", cex.main=1.5,col.main="darkblue",names=c("Control","Treatment1","Treatment2"))
points(means,col="blue",pch=20)
```

## Lecture 71: Piecharts
Piecharts are quite often used for sales and marketing purposes. They are said to be able to manipulate the perception not often used in scientifit papers.
```{r}
?pie

# To create the slices and define size
slices=c(40,20,40)

# Name labes of the slices - WATCH the length
countries=c("US","UK","Other")

# To add the slice size to the labels 
countries=paste(countries,slices)

# To further specify the labels
countries=paste(countries,"%",sep="")

pie(slices,labels=countries,
    col=c("red","blue","white"),main="Sales Distribution")

?iris
head(iris)
attach(iris)
values=table(Species)
labels=paste(names(Values))
pie(Values,labels=labels,main="Species Distribution")

# 3D effect
# we need the library "plotrix"
install.packages("plotrix")
library(plotrix)

pie3D(slices, labels=countries,explode=0.05,
      col=c("red","blue","white"),main="Sales Distribution")
```

## Lecture 72: Histograms
Histogram gives a good ide of probability distribution. Histograms are divided into intervals or bins. 
```{r}
?hist

# Breaks determine the interval length
# We have the Sturgens also as preset
# We can define breaks ourselves 

?cars
ourdata=cars$speed
hist(ourdata)

# As you can see the breaks are not perfect

hist(ourdata,labels=T,breaks=c(0,5,10,20,30))
hist(ourdata,labels=T, breaks=10)
hist(ourdata,labels=T,ylim=c(0,10),breaks=10)


# Fit the axes for the cuve
hey=hist(ourdata,breaks=10)
xaxis=seq(min(ourdata),max(ourdata),length=10)
yaxis=dnorm(xaxis,mean=mean(ourdata),sd=sd(ourdata))
yaxis=yaxis*diff(hey$mids)*length(ourdata)

## Add the normal curve
lines(xaxis,yaxis,col="light blue")

# we can change from frequency to density
hist(ourdata, freq=F, breaks=10)

# and add the density line
lines(density(ourdata),col="blue",lwd=2)
```

## Lecture 73: Exercise and solution histograms

1. Get familar with the lynx dataset
2. Plot a simple histogram
3. Choose the right break number (right bin number)
4. Adjust heading and labs accoding to graph
5. Adjust the y axis scale horizontally
6. Insert the count number in the graph
6. Adjsut the graph area that every count number is visible
8. Add the coloration to the graph: hint - color vector
9. Add second heading line: hint - mtext
```{r}

hist(lynx,breaks=9,ylim=c(0,70),las=1,
     labels=T, col=c("White","Green"),
     main="Annual Lynx Trappings",xlab="Number of lynx treappings\n per year")

```

## Lecture 74: Advanced scatterplots and legends 
### Advanced scatterplots
We can plot several xy pars in one plot.
```{r}
set.seed(67)
x=rnorm(10,5,7)
y=rpois(10,7)
z=rnorm(10,6,7)
t=rpois(10,9)

# at first we create a simple scatter plot

plot(x,y,col=123,pch=10,main="Multi scatterplot",
     col.main="red",cex.main=1.5,xlab="indep",ylab="depend")

# Now we add another layer on our scatterplot
points(z,t,col="blue",pch=4)

# add the last one 
points(y,t,col=777,pch=9)

legend(-6,5,9,legend=c("level 1","level 2","level 3"),
       col=c(123,"blue",777),pch=c(10,4,9),cex=0.65,bty="n")

# This gives us a three layer multi scatterplot
```

### LEGENDS
We can add a legend to be able to understand our layered scatterplot. The first two numbers specify the position on the x y scale. Than we have legend names, colours (col) and sympols (pch) to be used in the 
```{r}
legend(-6,5,9,legend=c("level 1","level 2","level 3"),
       col=c(123,"blue",777),pch=c(10,4,9))
```

## Lecture 75: Exercise and solution scatterplots
1. Create the follwing vectors
```{r}
x=1:5
y=rep(4,5)
x1=1.1:5.1
y1=5:1
```

2. Now plot those 3 level in your scatterplot (x-y, x1-y1,x1-x)
```{r}

plot(x,y,xlab="",ylab="",
     cex.main=1.3,col.main=777,pch=3,col="red",bty="n")
points(x1,y1,col="green",pch=10)
points(x1,x,col="light blue",pch=9)

legend(1,3.5,legend=c("level 1","level 2","level 3"),
       col=c("red","green","blue"),pch=c(3,8,9),cex=0.75,bty="n")
```

# Section 8: Advanced topic: working with strings
## Lecture 77: Working with strings 

Strings is a type of data (mainly text data). 
Quotation"" are used to specify data as a string (character)
- mystring <- "this is a string!"

Strings are used for scraped data (e.g., twitter, Google), text based data (e.g., sentiment analysis) and text mining. 

To handle strings correcltly, R base offers useful features to handle strings (e.g., gsub). In addition, a sublanguage (regular expression)i sused and add-ons are available such as "stringr" and "gsubfunc"

Important notes: According to your location/computer, characters (e.g., from Twitter messages) may be encoded or used differently in your R session. For example, you might sometimes scrape texts is cyrillic or mandarin. Hence, usage of regular exrpession mght be slightly different.
```{r}
# changing the cases
tolower("Graphs and histograms")
toupper("Graphs and Histograms")

# splitting the string is a single character values
strsplit("Graphs and Histograms",NULL)

# splitting string after each space
strsplit("Graphs and Histograms","")



```

## Lecture 78:Working with strings - gsub
Gsub famly is useful for substitution in strings. 

```{r}
# lets get a character vector with 2strings 
teststring <- c("my teststring to explain how substition with my R base works","another teststring for My example of gsub and sub")

# output
teststring

# 1. structure of the sub/gsub family
gsub("my","OUR",teststring)

# 2. difference 
sub("my","OUR",teststring)

# 3. working with cases - see the last string MY
gsub("my","OUR",teststring,ignore.case=T)

# 4. working with numbers - deleting numbers
numberstring <- c("3445 is GReater than 23 - @!$")
numberstring

# we need to check the regular expression syntax to see how digits are encoded.
gsub("\\d","",numberstring)

# now we go to the other way round and replace anything not being a digit
gsub("\\D","",numberstring)

# 5. avoid the spaces
gsub("\\s","",numberstring)

# 6. advanced methods 

```

## Lecture 79: Working with strings - gsub advanced

Syntax
- \\d:digit, 0,1,2,...,9
- \\D: not digit
- \\s: space 
- \\S: not space
- \\w: word
- \\t: tab 
- \\n: new line
- ^: beginning of the string 

```{r}
## 6. advanced methods 

# lets exchange specific letters with "Q"
gsub("[iot]","Q",numberstring)

# removing punctuation
gsub("[[:punct:]]","",numberstring)

# removing anything but graphical characters
gsub("[^[:graph:]]","",numberstring)

# package stringer offers several useful functions for string handling
install.packages("stringer")
library(Stringer)
# adding strings together
str_c(c(numberstring,teststring),sep="")
# we can count the ocurences of a specific symbol in an element
str_count(numberstring,"3")

```

## Lecture 81: Working with strings - Library stringr
When you want to check functions, access the help for the package.

Package stringer offers several useful functions for string handling.
```{r}
library(stringr)

teststring <- c("my teststring to explaing how substitution with my R base", "another testsring for my example of gsub and sub")

numberstring <- c("3445 is GReater than 23 - @!$", "Tom coded 11 JAva scripts and 23 python scripts")

# adding strings together
str_c(c(numberstring,teststring),sep="")

# we can count the ocurrences of a specific symbol in an element
str_count(numberstring,"3")

# we can locate the first and last position of a symbol in a given string
str_locate_all(numberstring,"3")

# replacement similar to sub - first occurence
str_replace(numberstring,"\\d","")

# and gsub - all occurences
str_replace_all(numberstring,"\\d","")

```

library(gsubfn) can be used to incroporate functions to gsub.

## Lecture 82: working with strings exercise

```{r}
ourstring <- c("Tom found 74 apples","Is this a question",
               "How many $ and % doEs it cost?")
```

Questions
1. put the string to complete lowercase
2. remove the punctuation
3. remove the spaces
4. remove the % sign (if you have it on your keyboard)
5. use str_extract_all from stringer to see which element contains "is"
```{r}
#1. solution
(ourstring = tolower(ourstring))

#2. solution
(outstring=gsub("[[:punct:]]","",ourstring))


#3. solution 
(ourstring=gsub("\\s","",ourstring))

#4. solution
(ourstring=gsub("%","",ourstring))

#5 solution
str_extract_all(ourstring,"is")
```

# Section 9: Using the R commander GUI 

GUI in R commander 
```{r}
install.packages("Rcmdr")
```














